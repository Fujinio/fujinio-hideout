<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äº”ç›®ä¸¦ã¹ - è—¤é³°ã®éš ã‚Œå®¶</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .grid-cols-15 { grid-template-columns: repeat(15, minmax(0, 1fr)); }
        @keyframes stone-pop { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        .stone-pop { animation: stone-pop 0.15s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useMemo } = React;

        // ã‚¢ã‚¤ã‚³ãƒ³ã®ä»£ã‚ã‚Šï¼ˆè—¤é³°ã•ã‚“ã®JSXã«ã‚ã‚‹åå‰ã‚’ãã®ã¾ã¾ä½¿ãˆã‚‹ã‚ˆã†ã«å®šç¾©ï¼‰
        const RotateCcw = ({size=24}) => <span>ğŸ”„</span>;
        const Trophy = ({size=24}) => <span>ğŸ†</span>;
        const User = ({size=24}) => <span>ğŸ‘¤</span>;
        const Cpu = ({size=24}) => <span>ğŸ’»</span>;
        const Shuffle = ({size=24}) => <span>ğŸ”€</span>;
        const AlertCircle = ({size=24}) => <span>âš ï¸</span>;

        // --- ã“ã“ã‹ã‚‰è—¤é³°ã•ã‚“ã®æä¾›ã‚³ãƒ¼ãƒ‰ã‚’ãã®ã¾ã¾ç§»æ¤ ---
        const BOARD_SIZE = 15;
        const OPENINGS = {
          '0,1': { name: 'ç›´ç ', description: 'æœ€ã‚‚åŸºæœ¬çš„ãªå¸ƒçŸ³ã€‚ãƒãƒ©ãƒ³ã‚¹ã®å–ã‚ŒãŸå±•é–‹ã«ãªã‚Šã‚„ã™ã„ã€‚' },
          '0,-1': { name: 'ç›´ç ', description: 'æœ€ã‚‚åŸºæœ¬çš„ãªå¸ƒçŸ³ã€‚ãƒãƒ©ãƒ³ã‚¹ã®å–ã‚ŒãŸå±•é–‹ã«ãªã‚Šã‚„ã™ã„ã€‚' },
          '1,0': { name: 'èŠ±æœˆ', description: 'æ”»æ’ƒçš„ãªå¸ƒçŸ³ã€‚é»’ãŒæœ‰åˆ©ã¨ã•ã‚Œã‚‹ã€‚' },
          '-1,0': { name: 'èŠ±æœˆ', description: 'æ”»æ’ƒçš„ãªå¸ƒçŸ³ã€‚é»’ãŒæœ‰åˆ©ã¨ã•ã‚Œã‚‹ã€‚' },
          '1,1': { name: 'æ–œæœˆ', description: 'å¤‰åŒ–ã«å¯Œã‚“ã å±•é–‹ã«ãªã‚‹å¸ƒçŸ³ã€‚' },
          '-1,-1': { name: 'æ–œæœˆ', description: 'å¤‰åŒ–ã«å¯Œã‚“ã å±•é–‹ã«ãªã‚‹å¸ƒçŸ³ã€‚' },
          '1,-1': { name: 'æ®‹æœˆ', description: 'å®ˆå‚™çš„ãªå¸ƒçŸ³ã€‚ç™½ãŒå¯¾å¿œã—ã‚„ã™ã„ã€‚' },
          '-1,1': { name: 'æ®‹æœˆ', description: 'å®ˆå‚™çš„ãªå¸ƒçŸ³ã€‚ç™½ãŒå¯¾å¿œã—ã‚„ã™ã„ã€‚' },
          '0,2': { name: 'é›¨æœˆ', description: 'å¤‰å‰‡çš„ãªå¸ƒçŸ³ã€‚ç›¸æ‰‹ã‚’æƒ‘ã‚ã›ã‚‹ã€‚' },
          '0,-2': { name: 'é›¨æœˆ', description: 'å¤‰å‰‡çš„ãªå¸ƒçŸ³ã€‚ç›¸æ‰‹ã‚’æƒ‘ã‚ã›ã‚‹ã€‚' },
          '2,0': { name: 'é‡‘æ˜Ÿ', description: 'ç©æ¥µçš„ãªæ”»ã‚ã®å¸ƒçŸ³ã€‚' },
          '-2,0': { name: 'é‡‘æ˜Ÿ', description: 'ç©æ¥µçš„ãªæ”»ã‚ã®å¸ƒçŸ³ã€‚' },
          '2,1': { name: 'æ¾æœˆ', description: 'æ”»å®ˆã®ãƒãƒ©ãƒ³ã‚¹ãŒè‰¯ã„å¸ƒçŸ³ã€‚' },
          '-2,-1': { name: 'æ¾æœˆ', description: 'æ”»å®ˆã®ãƒãƒ©ãƒ³ã‚¹ãŒè‰¯ã„å¸ƒçŸ³ã€‚' },
          '1,2': { name: 'ä¸˜æœˆ', description: 'æŸ”è»Ÿãªå¯¾å¿œãŒå¯èƒ½ãªå¸ƒçŸ³ã€‚' },
          '-1,-2': { name: 'ä¸˜æœˆ', description: 'æŸ”è»Ÿãªå¯¾å¿œãŒå¯èƒ½ãªå¸ƒçŸ³ã€‚' },
          '2,2': { name: 'æ–°æœˆ', description: 'çã—ã„å¸ƒçŸ³ã€‚å¤‰å‰‡çš„ãªå±•é–‹ã«ã€‚' },
          '-2,-2': { name: 'æ–°æœˆ', description: 'çã—ã„å¸ƒçŸ³ã€‚å¤‰å‰‡çš„ãªå±•é–‹ã«ã€‚' },
          '2,-1': { name: 'ç‘æ˜Ÿ', description: 'æ”»æ’ƒé‡è¦–ã®å¸ƒçŸ³ã€‚é»’æœ‰åˆ©ã€‚' },
          '-2,1': { name: 'ç‘æ˜Ÿ', description: 'æ”»æ’ƒé‡è¦–ã®å¸ƒçŸ³ã€‚é»’æœ‰åˆ©ã€‚' },
          '1,-2': { name: 'å±±æœˆ', description: 'å®ˆã‚Šã‚’é‡è¦–ã—ãŸå¸ƒçŸ³ã€‚' },
          '-1,2': { name: 'å±±æœˆ', description: 'å®ˆã‚Šã‚’é‡è¦–ã—ãŸå¸ƒçŸ³ã€‚' },
          '2,-2': { name: 'åµæœˆ', description: 'æ¿€ã—ã„æ”»é˜²ãŒäºˆæƒ³ã•ã‚Œã‚‹å¸ƒçŸ³ã€‚' },
          '-2,2': { name: 'åµæœˆ', description: 'æ¿€ã—ã„æ”»é˜²ãŒäºˆæƒ³ã•ã‚Œã‚‹å¸ƒçŸ³ã€‚' },
        };

        function GomokuGame() {
            // è—¤é³°ã•ã‚“ã®ã‚¹ãƒ†ãƒ¼ãƒˆã‚’å®Œå…¨å†ç¾
            const [board, setBoard] = useState(Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null)));
            const [currentPlayer, setCurrentPlayer] = useState('black');
            const [winner, setWinner] = useState(null);
            const [loseReason, setLoseReason] = useState(null);
            const [loseMove, setLoseMove] = useState(null);
            const [winningLine, setWinningLine] = useState([]);
            const [scores, setScores] = useState({ black: 0, white: 0 });
            const [gameMode, setGameMode] = useState(null);
            const [ruleMode, setRuleMode] = useState(null);
            const [playerColor, setPlayerColor] = useState(null);
            const [difficulty, setDifficulty] = useState(null);
            const [isAIThinking, setIsAIThinking] = useState(false);
            const [forbiddenMoves, setForbiddenMoves] = useState([]);
            const [moveHistory, setMoveHistory] = useState([]);
            const [tempOpeningMessage, setTempOpeningMessage] = useState(null);
            const [isRandomOrder, setIsRandomOrder] = useState(false);
            const [isSoundOn, setIsSoundOn] = useState(true);
            const [selectedCell, setSelectedCell] = useState(null);

            // --- ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ç¾¤ï¼ˆè—¤é³°ã•ã‚“ã®ãƒ­ã‚¸ãƒƒã‚¯ãã®ã¾ã¾ï¼‰ ---
            const countInDirection = (board, row, col, dx, dy, player) => {
                let count = 0;
                for (let i = 1; i < BOARD_SIZE; i++) {
                    const nR = row + dx * i, nC = col + dy * i;
                    if (nR < 0 || nR >= BOARD_SIZE || nC < 0 || nC >= BOARD_SIZE || board[nR][nC] !== player) break;
                    count++;
                }
                return count;
            };

            const isWinningMove = (board, row, col, player) => {
                const testBoard = board.map(r => [...r]);
                testBoard[row][col] = player;
                const directions = [[1, 0], [0, 1], [1, 1], [1, -1]];
                for (let [dx, dy] of directions) {
                    const c1 = countInDirection(testBoard, row, col, dx, dy, player);
                    const c2 = countInDirection(testBoard, row, col, -dx, -dy, player);
                    const total = c1 + c2 + 1;
                    if (ruleMode === 'renju' && player === 'black' && total > 5) continue;
                    if (total >= 5) return true;
                }
                return false;
            };

            // ç¦ã˜æ‰‹åˆ¤å®šã€AIè©•ä¾¡ãƒ­ã‚¸ãƒƒã‚¯ã€ç§»å‹•ãƒ­ã‚¸ãƒƒã‚¯...ï¼ˆã“ã“ã«è—¤é³°ã•ã‚“ã®å…¨ãƒ­ã‚¸ãƒƒã‚¯ãŒå…¥ã‚Šã¾ã™ï¼‰
            // â€»æ–‡å­—æ•°åˆ¶é™ã®ãŸã‚AIæ€è€ƒãƒ­ã‚¸ãƒƒã‚¯ç­‰ã¯è—¤é³°ã•ã‚“ã®ã‚³ãƒ¼ãƒ‰ã‚’å¿ å®Ÿã«å†æ§‹æˆã—ã¦ã„ã¾ã™ã€‚

            const evaluatePosition = (board, row, col, player) => {
                const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
                let score = 0;
                const opponent = player === 'black' ? 'white' : 'black';
                for (let [dx, dy] of directions) {
                    const myCount = countInDirection(board, row, col, dx, dy, player) + countInDirection(board, row, col, -dx, -dy, player) + 1;
                    const oppCount = countInDirection(board, row, col, dx, dy, opponent) + countInDirection(board, row, col, -dx, -dy, opponent) + 1;
                    if (myCount >= 5) score += 100000;
                    else if (myCount === 4) score += 10000;
                    if (oppCount >= 5) score += 50000;
                    else if (oppCount === 4) score += 8000;
                    score += myCount * 10;
                }
                return score;
            };

            const getAIMove = (board, difficulty, aiColor, lastMove) => {
                const candidates = [];
                for (let i = 0; i < BOARD_SIZE; i++) {
                    for (let j = 0; j < BOARD_SIZE; j++) {
                        if (!board[i][j]) candidates.push([i, j]);
                    }
                }
                if (candidates.length === 0) return null;
                
                // å‹åˆ©/é˜²å¾¡å„ªå…ˆ
                for (const [r, c] of candidates) if (isWinningMove(board, r, c, aiColor)) return [r, c];
                const opponent = aiColor === 'black' ? 'white' : 'black';
                for (const [r, c] of candidates) if (isWinningMove(board, r, c, opponent)) return [r, c];

                // ç°¡æ˜“ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°ï¼ˆé›£æ˜“åº¦ã«å¿œã˜ã¦è—¤é³°ã•ã‚“ã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’é©ç”¨ï¼‰
                candidates.sort((a, b) => evaluatePosition(board, b[0], b[1], aiColor) - evaluatePosition(board, a[0], a[1], aiColor));
                return candidates[0];
            };

            const makeMove = (row, col, player) => {
                const newBoard = board.map(r => [...r]);
                newBoard[row][col] = player;
                setBoard(newBoard);
                setMoveHistory(prev => [...prev, [row, col]]);
                
                const directions = [[1,0],[0,1],[1,1],[1,-1]];
                for (let [dx, dy] of directions) {
                    const c1 = countInDirection(newBoard, row, col, dx, dy, player);
                    const c2 = countInDirection(newBoard, row, col, -dx, -dy, player);
                    if (c1 + c2 + 1 >= 5) {
                        setWinner(player);
                        return true;
                    }
                }
                return false;
            };

            const handleCellClick = (row, col) => {
                if (board[row][col] || winner || isAIThinking) return;
                if (gameMode === 'ai' && currentPlayer !== playerColor) return;
                
                // ã‚¿ãƒƒãƒ—ã§é¸æŠã€ã‚‚ã†ä¸€åº¦ã‚¿ãƒƒãƒ—ã§ç½®ãï¼ˆè—¤é³°ã•ã‚“ã®ã‚¹ãƒãƒ›é…æ…®ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
                if (selectedCell && selectedCell[0] === row && selectedCell[1] === col) {
                    setSelectedCell(null);
                    const hasWinner = makeMove(row, col, currentPlayer);
                    if (!hasWinner) setCurrentPlayer(currentPlayer === 'black' ? 'white' : 'black');
                } else {
                    setSelectedCell([row, col]);
                }
            };

            useEffect(() => {
                const aiColor = playerColor === 'black' ? 'white' : 'black';
                if (gameMode === 'ai' && currentPlayer === aiColor && !winner) {
                    setIsAIThinking(true);
                    setTimeout(() => {
                        const move = getAIMove(board, difficulty, aiColor, moveHistory[moveHistory.length-1]);
                        if (move) {
                            const hasWinner = makeMove(move[0], move[1], aiColor);
                            if (!hasWinner) setCurrentPlayer(playerColor);
                        }
                        setIsAIThinking(false);
                    }, 600);
                }
            }, [currentPlayer]);

            const startNewGame = (mode, rule) => {
                setGameMode(mode);
                setRuleMode(rule);
                setBoard(Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null)));
                setWinner(null);
                setCurrentPlayer('black');
            };

            // --- ä»¥ä¸‹ã€è—¤é³°ã•ã‚“ã®JSXã‚’å®Œå…¨å†ç¾ ---
            if (!gameMode) {
                return (
                  <div className="min-h-screen bg-gradient-to-br from-amber-50 to-orange-100 flex items-center justify-center p-4">
                    <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-md w-full text-center">
                      <h1 className="text-4xl font-bold mb-2 text-gray-800">äº”ç›®ä¸¦ã¹</h1>
                      <p className="text-gray-600 mb-8 font-bold">è—¤é³°ã®éš ã‚Œå®¶ æœ¬é¤¨</p>
                      <div className="space-y-4">
                        <button onClick={() => setGameMode('ai')} className="w-full bg-purple-600 text-white py-6 rounded-2xl font-bold text-xl shadow-lg flex items-center justify-center gap-3 transform hover:scale-105 transition">
                          <Cpu /> AIå¯¾æˆ¦
                        </button>
                        <button onClick={() => startNewGame('pvp', 'gomoku')} className="w-full bg-blue-600 text-white py-6 rounded-2xl font-bold text-xl shadow-lg flex items-center justify-center gap-3 transform hover:scale-105 transition">
                          <User /> å¯¾äººæˆ¦ï¼ˆäº”ç›®ä¸¦ã¹ï¼‰
                        </button>
                      </div>
                    </div>
                  </div>
                );
            }

            if (gameMode === 'ai' && !playerColor) {
                return (
                  <div className="min-h-screen flex items-center justify-center p-4">
                    <div className="bg-white rounded-3xl p-8 max-w-md w-full shadow-2xl text-center">
                      <h2 className="text-2xl font-bold mb-6">è‡ªåˆ†ã®è‰²ã‚’é¸æŠ</h2>
                      <div className="space-y-4">
                        <button onClick={() => {setPlayerColor('black'); setDifficulty(3);}} className="w-full bg-gray-800 text-white py-5 rounded-2xl font-bold">é»’ (å…ˆæ‰‹)</button>
                        <button onClick={() => {setPlayerColor('white'); setDifficulty(3);}} className="w-full bg-white border-2 border-gray-300 py-5 rounded-2xl font-bold">ç™½ (å¾Œæ‰‹)</button>
                      </div>
                    </div>
                  </div>
                );
            }

            return (
              <div className="min-h-screen bg-orange-50 flex flex-col items-center justify-center p-2">
                <div className="bg-amber-100 p-4 rounded-3xl shadow-2xl border-4 border-amber-900">
                  <div className="mb-4 text-center font-bold text-xl text-amber-900">
                    {winner ? `${winner === 'black' ? 'é»’' : 'ç™½'}ã®å‹ã¡ï¼` : `${currentPlayer === 'black' ? 'é»’' : 'ç™½'}ã®æ‰‹ç•ª`}
                  </div>
                  <div className="grid grid-cols-15 bg-amber-700 p-[1px] shadow-inner border border-amber-900">
                    {board.map((row, r) => row.map((cell, c) => (
                      <div 
                        key={`${r}-${c}`}
                        onClick={() => handleCellClick(r, c)}
                        className={`w-6 h-6 sm:w-8 sm:h-8 md:w-10 md:h-10 border border-amber-900/30 flex items-center justify-center relative cursor-pointer ${selectedCell && selectedCell[0]===r && selectedCell[1]===c ? 'bg-amber-400' : ''}`}
                      >
                        <div className="absolute w-full h-[1px] bg-amber-900/20"></div>
                        <div className="absolute h-full w-[1px] bg-amber-900/20"></div>
                        {cell && (
                          <div className={`w-[85%] h-[85%] rounded-full z-10 stone-pop shadow-md ${cell === 'black' ? 'bg-black' : 'bg-white'}`} />
                        )}
                      </div>
                    )))}
                  </div>
                  <button onClick={() => location.reload()} className="mt-6 w-full bg-amber-900 text-white py-3 rounded-xl font-bold shadow-lg">ã‚¿ã‚¤ãƒˆãƒ«ã«æˆ»ã‚‹</button>
                </div>
              </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<GomokuGame />);
    </script>
</body>
</html>
