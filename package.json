import React, { useState, useEffect } from 'react';
import { RotateCcw, Trophy, User, Cpu, Settings, AlertCircle, Shuffle } from 'lucide-react';

const BOARD_SIZE = 15;
const CELL_SIZE = 'min(6vw, 6vh)';

const OPENINGS = {
  '0,1': { name: 'ç›´ç ', description: 'æœ€ã‚‚åŸºæœ¬çš„ãªå¸ƒçŸ³ã€‚ãƒãƒ©ãƒ³ã‚¹ã®å–ã‚ŒãŸå±•é–‹ã«ãªã‚Šã‚„ã™ã„ã€‚' },
  '0,-1': { name: 'ç›´ç ', description: 'æœ€ã‚‚åŸºæœ¬çš„ãªå¸ƒçŸ³ã€‚ãƒãƒ©ãƒ³ã‚¹ã®å–ã‚ŒãŸå±•é–‹ã«ãªã‚Šã‚„ã™ã„ã€‚' },
  '1,0': { name: 'èŠ±æœˆ', description: 'æ”»æ’ƒçš„ãªå¸ƒçŸ³ã€‚é»’ãŒæœ‰åˆ©ã¨ã•ã‚Œã‚‹ã€‚' },
  '-1,0': { name: 'èŠ±æœˆ', description: 'æ”»æ’ƒçš„ãªå¸ƒçŸ³ã€‚é»’ãŒæœ‰åˆ©ã¨ã•ã‚Œã‚‹ã€‚' },
  '1,1': { name: 'æ–œæœˆ', description: 'å¤‰åŒ–ã«å¯Œã‚“ã å±•é–‹ã«ãªã‚‹å¸ƒçŸ³ã€‚' },
  '-1,-1': { name: 'æ–œæœˆ', description: 'å¤‰åŒ–ã«å¯Œã‚“ã å±•é–‹ã«ãªã‚‹å¸ƒçŸ³ã€‚' },
  '1,-1': { name: 'æ®‹æœˆ', description: 'å®ˆå‚™çš„ãªå¸ƒçŸ³ã€‚ç™½ãŒå¯¾å¿œã—ã‚„ã™ã„ã€‚' },
  '-1,1': { name: 'æ®‹æœˆ', description: 'å®ˆå‚™çš„ãªå¸ƒçŸ³ã€‚ç™½ãŒå¯¾å¿œã—ã‚„ã™ã„ã€‚' },
  '0,2': { name: 'é›¨æœˆ', description: 'å¤‰å‰‡çš„ãªå¸ƒçŸ³ã€‚ç›¸æ‰‹ã‚’æƒ‘ã‚ã›ã‚‹ã€‚' },
  '0,-2': { name: 'é›¨æœˆ', description: 'å¤‰å‰‡çš„ãªå¸ƒçŸ³ã€‚ç›¸æ‰‹ã‚’æƒ‘ã‚ã›ã‚‹ã€‚' },
  '2,0': { name: 'é‡‘æ˜Ÿ', description: 'ç©æ¥µçš„ãªæ”»ã‚ã®å¸ƒçŸ³ã€‚' },
  '-2,0': { name: 'é‡‘æ˜Ÿ', description: 'ç©æ¥µçš„ãªæ”»ã‚ã®å¸ƒçŸ³ã€‚' },
  '2,1': { name: 'æ¾æœˆ', description: 'æ”»å®ˆã®ãƒãƒ©ãƒ³ã‚¹ãŒè‰¯ã„å¸ƒçŸ³ã€‚' },
  '-2,-1': { name: 'æ¾æœˆ', description: 'æ”»å®ˆã®ãƒãƒ©ãƒ³ã‚¹ãŒè‰¯ã„å¸ƒçŸ³ã€‚' },
  '1,2': { name: 'ä¸˜æœˆ', description: 'æŸ”è»Ÿãªå¯¾å¿œãŒå¯èƒ½ãªå¸ƒçŸ³ã€‚' },
  '-1,-2': { name: 'ä¸˜æœˆ', description: 'æŸ”è»Ÿãªå¯¾å¿œãŒå¯èƒ½ãªå¸ƒçŸ³ã€‚' },
  '2,2': { name: 'æ–°æœˆ', description: 'çã—ã„å¸ƒçŸ³ã€‚å¤‰å‰‡çš„ãªå±•é–‹ã«ã€‚' },
  '-2,-2': { name: 'æ–°æœˆ', description: 'çã—ã„å¸ƒçŸ³ã€‚å¤‰å‰‡çš„ãªå±•é–‹ã«ã€‚' },
  '2,-1': { name: 'ç‘æ˜Ÿ', description: 'æ”»æ’ƒé‡è¦–ã®å¸ƒçŸ³ã€‚é»’æœ‰åˆ©ã€‚' },
  '-2,1': { name: 'ç‘æ˜Ÿ', description: 'æ”»æ’ƒé‡è¦–ã®å¸ƒçŸ³ã€‚é»’æœ‰åˆ©ã€‚' },
  '1,-2': { name: 'å±±æœˆ', description: 'å®ˆã‚Šã‚’é‡è¦–ã—ãŸå¸ƒçŸ³ã€‚' },
  '-1,2': { name: 'å±±æœˆ', description: 'å®ˆã‚Šã‚’é‡è¦–ã—ãŸå¸ƒçŸ³ã€‚' },
  '2,-2': { name: 'åµæœˆ', description: 'æ¿€ã—ã„æ”»é˜²ãŒäºˆæƒ³ã•ã‚Œã‚‹å¸ƒçŸ³ã€‚' },
  '-2,2': { name: 'åµæœˆ', description: 'æ¿€ã—ã„æ”»é˜²ãŒäºˆæƒ³ã•ã‚Œã‚‹å¸ƒçŸ³ã€‚' },
};

export default function GomokuGame() {
  const [board, setBoard] = useState(Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null)));
  const [currentPlayer, setCurrentPlayer] = useState('black');
  const [winner, setWinner] = useState(null);
  const [loseReason, setLoseReason] = useState(null);
  const [loseMove, setLoseMove] = useState(null);
  const [winningLine, setWinningLine] = useState([]);
  const [scores, setScores] = useState({ black: 0, white: 0 });
  const [gameMode, setGameMode] = useState(null);
  const [ruleMode, setRuleMode] = useState(null);
  const [playerColor, setPlayerColor] = useState(null);
  const [difficulty, setDifficulty] = useState(null);
  const [isAIThinking, setIsAIThinking] = useState(false);
  const [forbiddenMoves, setForbiddenMoves] = useState([]);
  const [moveHistory, setMoveHistory] = useState([]);
  const [tempOpeningMessage, setTempOpeningMessage] = useState(null);
  const [isRandomOrder, setIsRandomOrder] = useState(false);
  const [isSoundOn, setIsSoundOn] = useState(true);

  const playSound = () => {
    if (!isSoundOn) return;
    const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBTGH0fPTgjMGHm7A7+OZSA0PVqzn77BdGAg+ltryxnMoBSp+zPLaizsIGGS57OihUBELTKXh8bllHAU2jdXzzn0vBSR3yO/glEcOEVyz6OyrWBUIQ5zd8sFuIwUuhM/z1YU2Bhxqvu7mnEoODlOq5O+zYBoGPJPY88p2KwUme8rx3I4+CRZiturqpVITC0mi4PG8aB8GM4nU8tGAMQYfb8Lv45ZGDRBUr+bwsF4aCECY3PLEcSYEK4HO8tiJOQgZaLvt559NEAxRqOPwtmMcBjiP1/PMeS0GI3fH8N+RQAoUXrTp66hVFApGnt/yvmwhBTCG0fPTgzMHHm3A7+OZSA0PVqzm77BeGQc9ltvyxnUoBSp+zPDajDsIG2W67OihUBELTKXh8bllHAU1jdXzzn0vBSN4yO/glEcOEV2y6OyrWRUIQ5zd8sFuJAUthM/z1YU2Bhxqvu7mnEoPDlOq5O+zYRsGPJLZ88p3KwUme8rx3I4+CRVht+rqpVITC0mi4PG8aiAFM4nU8tGAMQYfb8Lv45ZGDRBTr+bwsF4aCECY3PLEcSYGK4DN8tiIOQgZZ7zt559NEAxRqOPwtmMdBTiP1/PMeS0GI3fH79+RQAoUXrTp66hVFApGnt/yvmwhBTCG0fPTgzMHHW3A7+OZRw0PVqzm77BeGQc9ltrzxnUoBSp9y/DajDsIG2W67OihUBELTKXh8bllHAU1jdT0zn0vBSN4yO/glEcOEV2y6OyrWRUIQ5zd8sFuJAUthM/z1YU2Bhxqvu7mnEoPDlOq5O+zYRsGPJLZ88p3KwUme8rx3I4+CRVht+rqpVITC0mi4PG8aiAFM4nU8tGAMQYfb8Lv45ZGDRBTr+bwsF4aCECY3PLEcSYGK4DN8tiIOQgZZ7zt559NEAxRqOPwtmMdBTiP1/PMeS0GI3fH79+RQAoUXrTp66hVFApGnt/yvmwhBTCG0fPTgzMHHW3A7+OZRw0PVqzm77BeGQc9ltrzxnUoBSp9y/DajDsIG2W67OihUBELTKXh8bllHAU1jdT0zn0vBSN4yO/glEcOEV2y6OyrWRUIQ5zd8sFuJAUthM/z1YU2Bhxqvu7mnEoPDlOq5O+zYRsGPJLZ88p3KwUme8rx3I4+CRVht+rqpVITC0mi4PG8aiAFM4nU8tGAMQYfb8Lv45ZGDRBTr+bwsF4aCECY3PLEcSYGK4DN8tiIOQgZZ7zt559NEAxRqOPwtmMdBTiP1/PMeS0GI3fH79+RQAoUXrTp66hVFApGnt/yvmwhBTCG0fPTgzMHHW3A7+OZRw0PVqzm77BeGQc9ltrzxnUoBSp9y/DajDsIG2W67OihUBELTKXh8bllHAU1jdT0zn0vBSN4yO/glEcOEV2y6OyrWRUIQ5zd8sFuJAUthM/z1YU2Bhxqvu7mnEoPDlOq5O+zYRsGPJLZ88p3KwUme8rx3I4+CRVht+rqpVITC0mi4PG8aiAFM4nU8tGAMQYfb8Lv45ZGDRBTr+bwsF4aCECY3PLEcSYGK4DN8tiIOQgZZ7zt559N');
    audio.volume = 0.3;
    audio.play().catch(() => {});
  };

  const countInDirection = (board, row, col, dx, dy, player) => {
    let count = 0;
    for (let i = 1; i < BOARD_SIZE; i++) {
      const newRow = row + dx * i;
      const newCol = col + dy * i;
      if (newRow < 0 || newRow >= BOARD_SIZE || newCol < 0 || newCol >= BOARD_SIZE) break;
      if (board[newRow][newCol] === player) {
        count++;
      } else {
        break;
      }
    }
    return count;
  };

  const isWinningMove = (board, row, col, player) => {
    const testBoard = board.map(r => [...r]);
    testBoard[row][col] = player;
    
    const directions = [[1, 0], [0, 1], [1, 1], [1, -1]];
    
    for (let [dx, dy] of directions) {
      const count1 = countInDirection(testBoard, row, col, dx, dy, player);
      const count2 = countInDirection(testBoard, row, col, -dx, -dy, player);
      const total = count1 + count2 + 1;
      
      if (ruleMode === 'renju' && player === 'black' && total > 5) {
        continue;
      }
      
      if (total >= 5) {
        return true;
      }
    }
    return false;
  };

  const checkOpenThree = (board, row, col, dx, dy) => {
    const testBoard = board.map(r => [...r]);
    testBoard[row][col] = 'black';
    
    const count1 = countInDirection(testBoard, row, col, dx, dy, 'black');
    const count2 = countInDirection(testBoard, row, col, -dx, -dy, 'black');
    const total = count1 + count2 + 1;
    
    if (total !== 3) return false;
    
    const end1Row = row + dx * (count1 + 1);
    const end1Col = col + dy * (count1 + 1);
    const end2Row = row - dx * (count2 + 1);
    const end2Col = col - dy * (count2 + 1);
    
    const open1 = end1Row >= 0 && end1Row < BOARD_SIZE && end1Col >= 0 && end1Col < BOARD_SIZE && 
                  testBoard[end1Row][end1Col] === null;
    const open2 = end2Row >= 0 && end2Row < BOARD_SIZE && end2Col >= 0 && end2Col < BOARD_SIZE && 
                  testBoard[end2Row][end2Col] === null;
    
    return open1 && open2;
  };

  const checkOpenFour = (board, row, col, dx, dy) => {
    const testBoard = board.map(r => [...r]);
    testBoard[row][col] = 'black';
    
    const count1 = countInDirection(testBoard, row, col, dx, dy, 'black');
    const count2 = countInDirection(testBoard, row, col, -dx, -dy, 'black');
    const total = count1 + count2 + 1;
    
    if (total !== 4) return false;
    
    const end1Row = row + dx * (count1 + 1);
    const end1Col = col + dy * (count1 + 1);
    const end2Row = row - dx * (count2 + 1);
    const end2Col = col - dy * (count2 + 1);
    
    const open1 = end1Row >= 0 && end1Row < BOARD_SIZE && end1Col >= 0 && end1Col < BOARD_SIZE && 
                  testBoard[end1Row][end1Col] === null;
    const open2 = end2Row >= 0 && end2Row < BOARD_SIZE && end2Col >= 0 && end2Col < BOARD_SIZE && 
                  testBoard[end2Row][end2Col] === null;
    
    return open1 || open2;
  };

  const isForbiddenMove = (board, row, col) => {
    if (ruleMode !== 'renju') return false;
    
    const testBoard = board.map(r => [...r]);
    testBoard[row][col] = 'black';
    
    const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
    
    let openThreeCount = 0;
    let openFourCount = 0;
    let maxLength = 0;
    
    for (let [dx, dy] of directions) {
      const count1 = countInDirection(testBoard, row, col, dx, dy, 'black');
      const count2 = countInDirection(testBoard, row, col, -dx, -dy, 'black');
      const total = count1 + count2 + 1;
      maxLength = Math.max(maxLength, total);
      
      if (checkOpenThree(board, row, col, dx, dy)) {
        openThreeCount++;
      }
      
      if (checkOpenFour(board, row, col, dx, dy)) {
        openFourCount++;
      }
    }
    
    if (openThreeCount >= 2) return 'ä¸‰ä¸‰ï¼ˆä¸¡ç«¯ãŒç©ºã„ãŸä¸‰ã‚’åŒæ™‚ã«2ã¤ä½œã‚‹ç¦ã˜æ‰‹ï¼‰';
    if (openFourCount >= 2) return 'å››å››ï¼ˆä¸¡ç«¯ã®ã©ã¡ã‚‰ã‹ãŒç©ºã„ãŸå››ã‚’åŒæ™‚ã«2ã¤ä½œã‚‹ç¦ã˜æ‰‹ï¼‰';
    if (maxLength > 5) return 'é•·é€£ï¼ˆ6å€‹ä»¥ä¸Šé€£ç¶šã§ä¸¦ã¹ã‚‹ç¦ã˜æ‰‹ï¼‰';
    
    return false;
  };

  const updateForbiddenMoves = (board) => {
    if (ruleMode !== 'renju' || currentPlayer !== 'black') {
      setForbiddenMoves([]);
      return;
    }
    
    const forbidden = [];
    for (let i = 0; i < BOARD_SIZE; i++) {
      for (let j = 0; j < BOARD_SIZE; j++) {
        if (!board[i][j] && isForbiddenMove(board, i, j)) {
          forbidden.push([i, j]);
        }
      }
    }
    setForbiddenMoves(forbidden);
  };

  const checkWinner = (board, row, col, player) => {
    const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];

    for (let [dx, dy] of directions) {
      let count = 1;
      let line = [[row, col]];
      
      for (let i = 1; i < 6; i++) {
        const newRow = row + dx * i;
        const newCol = col + dy * i;
        if (newRow >= 0 && newRow < BOARD_SIZE && newCol >= 0 && newCol < BOARD_SIZE && board[newRow][newCol] === player) {
          count++;
          line.push([newRow, newCol]);
        } else break;
      }
      
      for (let i = 1; i < 6; i++) {
        const newRow = row - dx * i;
        const newCol = col - dy * i;
        if (newRow >= 0 && newRow < BOARD_SIZE && newCol >= 0 && newCol < BOARD_SIZE && board[newRow][newCol] === player) {
          count++;
          line.unshift([newRow, newCol]);
        } else break;
      }
      
      if (ruleMode === 'renju' && player === 'black' && count > 5) {
        return null;
      }
      
      if (count >= 5) {
        return line.slice(0, 5);
      }
    }
    return null;
  };

  const checkOpenThreeForEval = (board, row, col, dx, dy, player) => {
    const testBoard = board.map(r => [...r]);
    testBoard[row][col] = player;
    
    const count1 = countInDirection(testBoard, row, col, dx, dy, player);
    const count2 = countInDirection(testBoard, row, col, -dx, -dy, player);
    const total = count1 + count2 + 1;
    
    if (total !== 3) return false;
    
    const end1Row = row + dx * (count1 + 1);
    const end1Col = col + dy * (count1 + 1);
    const end2Row = row - dx * (count2 + 1);
    const end2Col = col - dy * (count2 + 1);
    
    const open1 = end1Row >= 0 && end1Row < BOARD_SIZE && end1Col >= 0 && end1Col < BOARD_SIZE && 
                  testBoard[end1Row][end1Col] === null;
    const open2 = end2Row >= 0 && end2Row < BOARD_SIZE && end2Col >= 0 && end2Col < BOARD_SIZE && 
                  testBoard[end2Row][end2Col] === null;
    
    return open1 && open2;
  };

  const checkOpenFourForEval = (board, row, col, dx, dy, player) => {
    const testBoard = board.map(r => [...r]);
    testBoard[row][col] = player;
    
    const count1 = countInDirection(testBoard, row, col, dx, dy, player);
    const count2 = countInDirection(testBoard, row, col, -dx, -dy, player);
    const total = count1 + count2 + 1;
    
    if (total !== 4) return false;
    
    const end1Row = row + dx * (count1 + 1);
    const end1Col = col + dy * (count1 + 1);
    const end2Row = row - dx * (count2 + 1);
    const end2Col = col - dy * (count2 + 1);
    
    const open1 = end1Row >= 0 && end1Row < BOARD_SIZE && end1Col >= 0 && end1Col < BOARD_SIZE && 
                  testBoard[end1Row][end1Col] === null;
    const open2 = end2Row >= 0 && end2Row < BOARD_SIZE && end2Col >= 0 && end2Col < BOARD_SIZE && 
                  testBoard[end2Row][end2Col] === null;
    
    return open1 || open2;
  };

  const evaluatePosition = (board, row, col, player) => {
    const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
    let score = 0;
    
    let openFourCount = 0;
    let openThreeCount = 0;

    for (let [dx, dy] of directions) {
      const count1 = countInDirection(board, row, col, dx, dy, player);
      const count2 = countInDirection(board, row, col, -dx, -dy, player);
      const totalCount = count1 + count2 + 1;

      if (totalCount >= 5) score += 100000;
      else if (totalCount === 4) score += 10000;
      else if (totalCount === 3) score += 1000;
      else if (totalCount === 2) score += 100;
      else if (totalCount === 1) score += 10;
      
      if (checkOpenFourForEval(board, row, col, dx, dy, player)) {
        openFourCount++;
        score += 50000;
      }
      
      if (checkOpenThreeForEval(board, row, col, dx, dy, player)) {
        openThreeCount++;
        score += 30000;
      }
    }
    
    if (openFourCount >= 2) score += 100000;
    if (openThreeCount >= 2) score += 80000;
    if (openFourCount >= 1 && openThreeCount >= 1) score += 90000;

    return score;
  };

  const getAIMove = (board, difficulty, aiColor, lastPlayerMove) => {
    const center = Math.floor(BOARD_SIZE / 2);
    const totalMoves = board.flat().filter(cell => cell !== null).length;
    
    if (totalMoves === 0) {
      return [center, center];
    }

    const opponentColor = aiColor === 'black' ? 'white' : 'black';
    const candidates = [];
    
    for (let i = 0; i < BOARD_SIZE; i++) {
      for (let j = 0; j < BOARD_SIZE; j++) {
        if (board[i][j]) continue;
        
        if (aiColor === 'black' && ruleMode === 'renju' && isForbiddenMove(board, i, j)) {
          continue;
        }
        
        candidates.push([i, j]);
      }
    }

    if (candidates.length === 0) return null;

    for (const [r, c] of candidates) {
      if (isWinningMove(board, r, c, aiColor)) return [r, c];
    }
    for (const [r, c] of candidates) {
      if (isWinningMove(board, r, c, opponentColor)) return [r, c];
    }

    if (difficulty >= 3) {
      const opponentAttackMoves = candidates.map(([row, col]) => {
        const defenseScore = evaluatePosition(board, row, col, opponentColor);
        return { row, col, score: defenseScore };
      });

      opponentAttackMoves.sort((a, b) => b.score - a.score);

      if (opponentAttackMoves.length > 0 && opponentAttackMoves[0].score >= 30000) {
        return [opponentAttackMoves[0].row, opponentAttackMoves[0].col];
      }
    }

    if (difficulty === 1) {
      const radius = 3;
      const [pr, pc] = lastPlayerMove || [center, center];
      
      const filtered = candidates.filter(([r, c]) =>
        Math.abs(r - pr) <= radius && Math.abs(c - pc) <= radius
      );
      
      const finalCandidates = filtered.length > 0 ? filtered : candidates;
      const rand = Math.floor(Math.random() * finalCandidates.length);
      return finalCandidates[rand];
    }

    if (difficulty === 2) {
      if (Math.random() < 0.7) {
        const moves = candidates.map(([row, col]) => {
          const myScore = evaluatePosition(board, row, col, aiColor);
          const defScore = evaluatePosition(board, row, col, opponentColor);
          return { row, col, score: defScore * 1.5 + myScore * 1.0 };
        });
        moves.sort((a, b) => b.score - a.score);
        if (moves.length > 0 && moves[0].score > 1000) return [moves[0].row, moves[0].col];
      }
      
      candidates.sort((a, b) => {
        const da = Math.abs(a[0] - center) + Math.abs(a[1] - center);
        const db = Math.abs(b[0] - center) + Math.abs(b[1] - center);
        return da - db;
      });
      return candidates[0];
    }

    if (difficulty >= 3) {
      const moves = candidates.map(([row, col]) => {
        const myScore = evaluatePosition(board, row, col, aiColor);
        const defScore = evaluatePosition(board, row, col, opponentColor);
        let score = 0;
        if (difficulty === 3) score = myScore * 1.2 + defScore * 1.3;
        if (difficulty === 4) score = myScore * 1.3 + defScore * 1.5;
        if (difficulty === 5) score = myScore * 1.5 + defScore * 2.0;
        return { row, col, score };
      });
      
      moves.sort((a, b) => b.score - a.score);
      const topCount = difficulty === 5 ? 1 : Math.min(5, moves.length);
      const topMoves = moves.slice(0, topCount);
      const selected = topMoves[Math.floor(Math.random() * topMoves.length)];
      return [selected.row, selected.col];
    }

    return candidates[Math.floor(Math.random() * candidates.length)];
  };

  const checkOpening = (moves) => {
    if (moves.length !== 3) return null;
    
    const center = Math.floor(BOARD_SIZE / 2);
    const [first, second, third] = moves;
    
    if (first[0] !== center || first[1] !== center) return null;
    
    const dx = third[0] - first[0];
    const dy = third[1] - first[1];
    const key = `${dx},${dy}`;
    
    return OPENINGS[key] || null;
  };

  const makeMove = (row, col, player) => {
    if (player === 'black' && ruleMode === 'renju') {
      const forbidden = isForbiddenMove(board, row, col);
      if (forbidden) {
        setWinner('white');
        setLoseReason(forbidden);
        setLoseMove([row, col]);
        setScores(prev => ({ ...prev, white: prev.white + 1 }));
        return true;
      }
    }

    const newBoard = board.map(r => [...r]);
    newBoard[row][col] = player;
    setBoard(newBoard);
    
    const newHistory = [...moveHistory, [row, col]];
    setMoveHistory(newHistory);
    
    if (ruleMode === 'renju' && newHistory.length === 3) {
      const opening = checkOpening(newHistory);
      if (opening) {
        setTempOpeningMessage(opening.name);
        setTimeout(() => setTempOpeningMessage(null), 3000);
      }
    }

    const winLine = checkWinner(newBoard, row, col, player);
    if (winLine) {
      setWinner(player);
      setLoseReason(null);
      setWinningLine(winLine);
      setScores(prev => ({
        ...prev,
        [player]: prev[player] + 1
      }));
      return true;
    }
    return false;
  };

  const isPlaceableCell = (row, col) => {
    if (ruleMode !== 'renju') return true;
    if (winner) return false;
    
    const center = Math.floor(BOARD_SIZE / 2);
    const moveCount = moveHistory.length;
    
    if (moveCount === 0) {
      return row === center && col === center;
    } else if (moveCount === 1) {
      const rowDiff = Math.abs(row - center);
      const colDiff = Math.abs(col - center);
      return rowDiff <= 1 && colDiff <= 1 && !(rowDiff === 0 && colDiff === 0);
    } else if (moveCount === 2) {
      const rowDiff = Math.abs(row - center);
      const colDiff = Math.abs(col - center);
      return rowDiff <= 2 && colDiff <= 2;
    }
    
    return true;
  };

  const handleCellClick = (row, col) => {
    if (board[row][col] || winner || isAIThinking) return;
    if (gameMode === 'ai' && currentPlayer !== playerColor) return;

    const center = Math.floor(BOARD_SIZE / 2);

    if (ruleMode === 'renju') {
      const moveCount = moveHistory.length;
      
      if (moveCount === 0) {
        if (row !== center || col !== center) return;
      } else if (moveCount === 1) {
        const rowDiff = Math.abs(row - center);
        const colDiff = Math.abs(col - center);
        if (rowDiff > 1 || colDiff > 1 || (rowDiff === 0 && colDiff === 0)) return;
      } else if (moveCount === 2) {
        const rowDiff = Math.abs(row - center);
        const colDiff = Math.abs(col - center);
        if (rowDiff > 2 || colDiff > 2) return;
      }
    }

    playSound();
    const hasWinner = makeMove(row, col, currentPlayer);
    if (!hasWinner) {
      setCurrentPlayer(currentPlayer === 'black' ? 'white' : 'black');
    }
  };

  useEffect(() => {
    updateForbiddenMoves(board);
  }, [board, currentPlayer, ruleMode]);

  useEffect(() => {
    const aiColor = playerColor === 'black' ? 'white' : 'black';
    if (gameMode === 'ai' && currentPlayer === aiColor && !winner && !isAIThinking) {
      setIsAIThinking(true);
      const timer = setTimeout(() => {
        const lastPlayerMove = moveHistory.length > 0 ? moveHistory[moveHistory.length - 1] : null;
        const move = getAIMove(board, difficulty, aiColor, lastPlayerMove);
        if (move) {
          const [row, col] = move;
          const hasWinner = makeMove(row, col, aiColor);
          if (!hasWinner) {
            setCurrentPlayer(aiColor === 'black' ? 'white' : 'black');
          }
        }
        setIsAIThinking(false);
      }, 500);
      return () => clearTimeout(timer);
    }
  }, [currentPlayer, gameMode, winner, board, moveHistory]);

  const resetGame = () => {
    setBoard(Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null)));
    setCurrentPlayer('black');
    setWinner(null);
    setLoseReason(null);
    setLoseMove(null);
    setWinningLine([]);
    setIsAIThinking(false);
    setForbiddenMoves([]);
    setMoveHistory([]);
    setTempOpeningMessage(null);
    
    if (isRandomOrder && gameMode === 'ai') {
      const newPlayerColor = Math.random() < 0.5 ? 'black' : 'white';
      setPlayerColor(newPlayerColor);
    }
  };

  const startNewGame = (mode, rule) => {
    setGameMode(mode);
    setRuleMode(rule);
    setBoard(Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null)));
    setCurrentPlayer('black');
    setWinner(null);
    setLoseReason(null);
    setWinningLine([]);
    setIsAIThinking(false);
    setForbiddenMoves([]);
    if (mode === 'pvp') {
      setDifficulty(null);
      setPlayerColor(null);
    }
  };

  const isWinningCell = (row, col) => {
    return winningLine.some(([r, c]) => r === row && c === col);
  };

  const isForbiddenCell = (row, col) => {
    return forbiddenMoves.some(([r, c]) => r === row && c === col);
  };

  if (!gameMode) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-amber-50 to-orange-100 flex items-center justify-center p-4">
        <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-md w-full">
          <h1 className="text-4xl font-bold text-center mb-2 text-gray-800">äº”ç›®ä¸¦ã¹</h1>
          <p className="text-center text-gray-600 mb-8">ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ã‚’é¸æŠ</p>
          
          <div className="space-y-4">
            <button
              onClick={() => setGameMode('ai')}
              className="w-full bg-gradient-to-r from-purple-500 to-purple-600 text-white py-6 rounded-2xl font-bold text-xl shadow-lg hover:from-purple-600 hover:to-purple-700 transition-all transform hover:scale-105 flex items-center justify-center gap-3"
            >
              <Cpu size={28} />
              AIå¯¾æˆ¦
            </button>
            
            <button
              onClick={() => startNewGame('pvp', 'gomoku')}
              className="w-full bg-gradient-to-r from-blue-500 to-blue-600 text-white py-6 rounded-2xl font-bold text-xl shadow-lg hover:from-blue-600 hover:to-blue-700 transition-all transform hover:scale-105 flex items-center justify-center gap-3"
            >
              <User size={28} />
              å¯¾äººæˆ¦ï¼ˆäº”ç›®ä¸¦ã¹ï¼‰
            </button>
            
            <button
              onClick={() => startNewGame('pvp', 'renju')}
              className="w-full bg-gradient-to-r from-cyan-500 to-cyan-600 text-white py-6 rounded-2xl font-bold text-xl shadow-lg hover:from-cyan-600 hover:to-cyan-700 transition-all transform hover:scale-105 flex items-center justify-center gap-3"
            >
              <User size={28} />
              å¯¾äººæˆ¦ï¼ˆé€£ç ï¼‰
            </button>
          </div>
        </div>
      </div>
    );
  }

  if (gameMode === 'ai' && !ruleMode) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-amber-50 to-orange-100 flex items-center justify-center p-4">
        <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-md w-full">
          <h1 className="text-3xl font-bold text-center mb-2 text-gray-800">ãƒ«ãƒ¼ãƒ«ã‚’é¸æŠ</h1>
          <p className="text-center text-gray-600 mb-8">å¯¾æˆ¦ãƒ«ãƒ¼ãƒ«ã‚’é¸ã‚“ã§ãã ã•ã„</p>
          
          <div className="space-y-4">
            <button
              onClick={() => setRuleMode('gomoku')}
              className="w-full bg-gradient-to-r from-blue-500 to-blue-600 text-white py-6 rounded-2xl font-bold text-xl shadow-lg hover:from-blue-600 hover:to-blue-700 transition-all transform hover:scale-105"
            >
              äº”ç›®ä¸¦ã¹
              <div className="text-sm font-normal mt-1">é€šå¸¸ãƒ«ãƒ¼ãƒ«</div>
            </button>
            
            <button
              onClick={() => setRuleMode('renju')}
              className="w-full bg-gradient-to-r from-cyan-500 to-cyan-600 text-white py-6 rounded-2xl font-bold text-xl shadow-lg hover:from-cyan-600 hover:to-cyan-700 transition-all transform hover:scale-105"
            >
              é€£ç 
              <div className="text-sm font-normal mt-1">é»’ã«ç¦ã˜æ‰‹ã‚ã‚Š</div>
            </button>
          </div>
          
          <button
            onClick={() => setGameMode(null)}
            className="w-full mt-6 px-4 py-3 bg-gray-400 text-white rounded-xl hover:bg-gray-500 transition"
          >
            ãƒ¢ãƒ¼ãƒ‰é¸æŠã«æˆ»ã‚‹
          </button>
        </div>
      </div>
    );
  }

  if (gameMode === 'ai' && !playerColor) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-amber-50 to-orange-100 flex items-center justify-center p-4">
        <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-md w-full">
          <h1 className="text-3xl font-bold text-center mb-2 text-gray-800">å…ˆæ‰‹ãƒ»å¾Œæ‰‹ã‚’é¸æŠ</h1>
          <p className="text-center text-gray-600 mb-8">ã‚ãªãŸã®è‰²ã‚’é¸ã‚“ã§ãã ã•ã„</p>
          
          <div className="space-y-4">
            <button
              onClick={() => setPlayerColor('black')}
              className="w-full bg-gradient-to-r from-gray-700 to-gray-900 text-white py-6 rounded-2xl font-bold text-xl shadow-lg hover:from-gray-800 hover:to-black transition-all transform hover:scale-105"
            >
              é»’ï¼ˆå…ˆæ‰‹ï¼‰
              <div className="text-sm font-normal mt-1">æœ€åˆã«æ‰“ã¤</div>
            </button>
            
            <button
              onClick={() => setPlayerColor('white')}
              className="w-full bg-gradient-to-r from-gray-100 to-gray-300 text-gray-800 py-6 rounded-2xl font-bold text-xl shadow-lg hover:from-gray-200 hover:to-gray-400 transition-all transform hover:scale-105 border-2 border-gray-400"
            >
              ç™½ï¼ˆå¾Œæ‰‹ï¼‰
              <div className="text-sm font-normal mt-1">å¾Œã‹ã‚‰æ‰“ã¤</div>
            </button>
            
            <button
              onClick={() => {
                setPlayerColor(Math.random() < 0.5 ? 'black' : 'white');
                setIsRandomOrder(true);
              }}
              className="w-full bg-gradient-to-r from-orange-400 to-orange-500 text-white py-6 rounded-2xl font-bold text-xl shadow-lg hover:from-orange-500 hover:to-orange-600 transition-all transform hover:scale-105 flex items-center justify-center gap-3"
            >
              <Shuffle size={24} />
              ãƒ©ãƒ³ãƒ€ãƒ 
            </button>
          </div>
          
          <button
            onClick={() => setRuleMode(null)}
            className="w-full mt-6 px-4 py-3 bg-gray-400 text-white rounded-xl hover:bg-gray-500 transition"
          >
            ãƒ«ãƒ¼ãƒ«é¸æŠã«æˆ»ã‚‹
          </button>
        </div>
      </div>
    );
  }

  if (gameMode === 'ai' && !difficulty) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-amber-50 to-orange-100 flex items-center justify-center p-4">
        <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-md w-full">
          <h1 className="text-3xl font-bold text-center mb-2 text-gray-800">é›£æ˜“åº¦ã‚’é¸æŠ</h1>
          <p className="text-center text-gray-600 mb-8">AIã®å¼·ã•ã‚’é¸ã‚“ã§ãã ã•ã„</p>
          
          <div className="space-y-3">
            <button
              onClick={() => { setDifficulty(1); resetGame(); }}
              className="w-full bg-gradient-to-r from-green-400 to-green-500 text-white py-5 rounded-2xl font-bold text-lg shadow-lg hover:from-green-500 hover:to-green-600 transition-all transform hover:scale-105"
            >
              â­ ã‚„ã•ã—ã„
              <div className="text-sm font-normal mt-1">åˆå¿ƒè€…å‘ã‘ãƒ»å‘¨å›²3ãƒã‚¹</div>
            </button>
            
            <button
              onClick={() => { setDifficulty(2); resetGame(); }}
              className="w-full bg-gradient-to-r from-yellow-400 to-yellow-500 text-white py-5 rounded-2xl font-bold text-lg shadow-lg hover:from-yellow-500 hover:to-yellow-600 transition-all transform hover:scale-105"
            >
              â­â­ ãµã¤ã†
              <div className="text-sm font-normal mt-1">ãƒãƒ©ãƒ³ã‚¹é‡è¦–</div>
            </button>
            
            <button
              onClick={() => { setDifficulty(3); resetGame(); }}
              className="w-full bg-gradient-to-r from-orange-400 to-orange-500 text-white py-5 rounded-2xl font-bold text-lg shadow-lg hover:from-orange-500 hover:to-orange-600 transition-all transform hover:scale-105"
            >
              â­â­â­ ã‚€ãšã‹ã—ã„
              <div className="text-sm font-normal mt-1">æ”»å®ˆã‚’è€ƒãˆã‚‹</div>
            </button>
            
            <button
              onClick={() => { setDifficulty(4); resetGame(); }}
              className="w-full bg-gradient-to-r from-red-500 to-red-600 text-white py-5 rounded-2xl font-bold text-lg shadow-lg hover:from-red-600 hover:to-red-700 transition-all transform hover:scale-105"
            >
              â­â­â­â­ è¶…ã‚€ãšã‹ã—ã„
              <div className="text-sm font-normal mt-1">æœ€å–„æ‰‹ã‚’ç‹™ã†</div>
            </button>
            
            <button
              onClick={() => { setDifficulty(5); resetGame(); }}
              className="w-full bg-gradient-to-r from-purple-700 to-purple-900 text-white py-5 rounded-2xl font-bold text-lg shadow-lg hover:from-purple-800 hover:to-black transition-all transform hover:scale-105"
            >
              â­â­â­â­â­ é”äºº
              <div className="text-sm font-normal mt-1">ç¦ã˜æ‰‹ãƒãƒ¡ã‚ã‚Š</div>
            </button>
          </div>
          
          <button
            onClick={() => setPlayerColor(null)}
            className="w-full mt-6 px-4 py-3 bg-gray-400 text-white rounded-xl hover:bg-gray-500 transition"
          >
            å…ˆæ‰‹å¾Œæ‰‹é¸æŠã«æˆ»ã‚‹
          </button>
        </div>
      </div>
    );
  }

  const difficultyName = ['', 'ã‚„ã•ã—ã„', 'ãµã¤ã†', 'ã‚€ãšã‹ã—ã„', 'è¶…ã‚€ãšã‹ã—ã„', 'é”äºº'][difficulty] || '';

  return (
    <div className="min-h-screen bg-gradient-to-br from-amber-50 to-orange-100 flex flex-col items-center justify-center p-2 sm:p-4">
      <style>{`
        @keyframes glow-pulse {
          0%, 100% {
            box-shadow: 0 0 10px 3px rgba(255, 255, 0, 0.8), 0 0 5px 1px rgba(255, 255, 0, 0.5);
            transform: scale(1.05);
          }
          50% {
            box-shadow: 0 0 20px 6px rgba(255, 255, 0, 1), 0 0 8px 2px rgba(255, 255, 0, 0.8);
            transform: scale(1);
          }
        }

        .winning-stone {
          animation: glow-pulse 0.8s ease-in-out infinite alternate;
        }

        @keyframes forbidden-flash {
          0%, 100% {
            box-shadow: 0 0 15px 5px rgba(255, 0, 0, 0.9);
          }
          50% {
            box-shadow: 0 0 5px 2px rgba(255, 0, 0, 0.5);
          }
        }

        .forbidden-stone {
          animation: forbidden-flash 0.6s ease-in-out infinite alternate;
        }

        @keyframes bounce-in {
          0% { transform: scale(0.5); opacity: 0; }
          50% { transform: scale(1.05); }
          100% { transform: scale(1); opacity: 1; }
        }

        .animate-bounce-in {
          animation: bounce-in 0.5s ease-out;
        }
      `}</style>

      <div className="bg-white rounded-2xl shadow-2xl p-3 sm:p-6 w-full max-w-2xl">
        <div className="flex justify-between items-center mb-3 sm:mb-4 flex-wrap gap-2">
          <div className="flex gap-2 sm:gap-4 items-center">
            <div className="text-center">
              <div className="w-8 h-8 sm:w-10 sm:h-10 bg-black rounded-full mb-1"></div>
              <div className="text-lg sm:text-xl font-bold">{scores.black}</div>
              {gameMode === 'ai' && playerColor === 'black' && (
                <div className="text-xs text-gray-600">YOU</div>
              )}
            </div>
            <div className="text-center">
              <div className="w-8 h-8 sm:w-10 sm:h-10 bg-white border-2 border-gray-800 rounded-full mb-1"></div>
              <div className="text-lg sm:text-xl font-bold">{scores.white}</div>
              {gameMode === 'ai' && playerColor === 'white' && (
                <div className="text-xs text-gray-600">YOU</div>
              )}
            </div>
          </div>
          
          <div className="flex gap-2 flex-wrap">
            <button
              onClick={() => setIsSoundOn(!isSoundOn)}
              className={`px-2 py-1 sm:px-3 sm:py-2 rounded-lg text-xs sm:text-sm transition flex items-center gap-1 ${
                isSoundOn ? 'bg-green-500 text-white hover:bg-green-600' : 'bg-gray-400 text-white hover:bg-gray-500'
              }`}
              title={isSoundOn ? 'åŠ¹æœéŸ³ ON' : 'åŠ¹æœéŸ³ OFF'}
            >
              <span>{isSoundOn ? 'ğŸ”Š' : 'ğŸ”‡'}</span>
            </button>

            {gameMode === 'ai' && (
              <button
                onClick={() => { setDifficulty(null); resetGame(); }}
                className="px-2 py-1 sm:px-3 sm:py-2 bg-purple-500 text-white rounded-lg text-xs sm:text-sm hover:bg-purple-600 transition flex items-center gap-1"
              >
                <Settings size={14} />
                {difficultyName}
              </button>
            )}
            
            <button
              onClick={() => setGameMode(null)}
              className="px-2 py-1 sm:px-3 sm:py-2 bg-gray-500 text-white rounded-lg text-xs sm:text-sm hover:bg-gray-600 transition"
            >
              ãƒ¡ãƒ‹ãƒ¥ãƒ¼
            </button>
            
            <button
              onClick={resetGame}
              className="px-2 py-1 sm:px-3 sm:py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition flex items-center gap-1"
            >
              <RotateCcw size={14} />
              <span className="text-xs sm:text-sm">ãƒªã‚»ãƒƒãƒˆ</span>
            </button>
          </div>
        </div>

        {ruleMode === 'renju' && (
          <div className="mb-2 p-2 bg-cyan-50 border border-cyan-200 rounded-lg text-xs sm:text-sm text-cyan-800 flex items-center gap-2">
            <AlertCircle size={16} />
            <span>é€£ç ãƒ¢ãƒ¼ãƒ‰: é»’ã®ç¦ã˜æ‰‹ï¼ˆä¸‰ä¸‰ãƒ»å››å››ãƒ»é•·é€£ï¼‰ã‚ã‚Š</span>
          </div>
        )}

        {tempOpeningMessage && (
          <div className="mb-3 sm:mb-4 p-3 sm:p-4 bg-green-500 rounded-xl text-center shadow-md animate-bounce-in">
            <span className="text-xl sm:text-2xl font-bold text-white">
              å¸ƒçŸ³ã€Œ{tempOpeningMessage}ã€ãŒæˆç«‹ï¼
            </span>
          </div>
        )}

        {winner && (
          <div className="mb-3 sm:mb-4 p-3 sm:p-4 bg-gradient-to-r from-yellow-400 to-orange-400 rounded-xl text-center">
            <div className="flex items-center justify-center gap-2 mb-2">
              <Trophy className="text-white" size={24} />
              <span className="text-xl sm:text-2xl font-bold text-white">
                {winner === 'black' ? 'é»’' : 'ç™½'}ã®å‹ã¡ï¼
              </span>
            </div>
            {loseReason && (
              <div className="text-sm text-white mt-2 bg-red-500 bg-opacity-30 p-2 rounded">
                {loseReason}
              </div>
            )}
          </div>
        )}

        {!winner && (
          <div className="mb-3 sm:mb-4 text-center">
            <div className="inline-flex items-center gap-2 bg-gray-100 px-4 sm:px-6 py-2 rounded-full">
              <div className={`w-4 h-4 sm:w-5 sm:h-5 rounded-full ${currentPlayer === 'black' ? 'bg-black' : 'bg-white border-2 border-gray-800'}`}></div>
              <span className="font-bold text-sm sm:text-base">
                {isAIThinking ? 'AIãŒè€ƒãˆä¸­...' : `${currentPlayer === 'black' ? 'é»’' : 'ç™½'}ã®ç•ª ${currentPlayer === 'black' ? '(å…ˆæ‰‹)' : '(å¾Œæ‰‹)'}`}
              </span>
            </div>
          </div>
        )}

        <div 
          className="bg-amber-700 p-2 sm:p-4 rounded-xl shadow-inner overflow-auto"
          style={{ maxHeight: '70vh' }}
        >
          <div 
            className="relative bg-amber-600"
            style={{ 
              width: `calc(${BOARD_SIZE} * ${CELL_SIZE})`,
              height: `calc(${BOARD_SIZE} * ${CELL_SIZE})`,
              margin: '0 auto',
              minWidth: `${BOARD_SIZE * 20}px`,
              minHeight: `${BOARD_SIZE * 20}px`
            }}
          >
            {Array.from({ length: BOARD_SIZE }).map((_, i) => (
              <div
                key={`h-${i}`}
                className="absolute bg-gray-800"
                style={{
                  left: 0,
                  right: 0,
                  top: `calc(${i} * ${CELL_SIZE} + ${CELL_SIZE} / 2)`,
                  height: '1px'
                }}
              />
            ))}
            
            {Array.from({ length: BOARD_SIZE }).map((_, i) => (
              <div
                key={`v-${i}`}
                className="absolute bg-gray-800"
                style={{
                  top: 0,
                  bottom: 0,
                  left: `calc(${i} * ${CELL_SIZE} + ${CELL_SIZE} / 2)`,
                  width: '1px'
                }}
              />
            ))}
            
            {board.map((row, rowIndex) =>
              row.map((cell, colIndex) => (
                <div
                  key={`${rowIndex}-${colIndex}`}
                  onClick={() => handleCellClick(rowIndex, colIndex)}
                  className={`absolute cursor-pointer flex items-center justify-center transition-opacity ${
                    !isPlaceableCell(rowIndex, colIndex) && !board[rowIndex][colIndex] ? 'opacity-30 bg-gray-400' : ''
                  }`}
                  style={{
                    left: `calc(${colIndex} * ${CELL_SIZE})`,
                    top: `calc(${rowIndex} * ${CELL_SIZE})`,
                    width: CELL_SIZE,
                    height: CELL_SIZE,
                    minWidth: '20px',
                    minHeight: '20px'
                  }}
                >
                  {!cell && isForbiddenCell(rowIndex, colIndex) && (
                    <div className="absolute w-full h-full flex items-center justify-center">
                      <div className="w-2 h-2 sm:w-3 sm:h-3 bg-red-500 opacity-70 rounded-full animate-pulse"></div>
                    </div>
                  )}
                  {cell && (
                    <div
                      className={`rounded-full ${
                        cell === 'black' ? 'bg-black' : 'bg-white border-2 border-gray-800'
                      } ${
                        isWinningCell(rowIndex, colIndex) ? 'winning-stone' : ''
                      } ${
                        winner && loseReason && cell === 'black' && loseMove && loseMove[0] === rowIndex && loseMove[1] === colIndex ? 'forbidden-stone' : ''
                      }`}
                      style={{ 
                        width: '75%', 
                        height: '75%',
                        boxShadow: '0 2px 4px rgba(0,0,0,0.3)'
                      }}
                    />
                  )}
                </div>
              ))
            )}
          </div>
        </div>
      </div>
    </div>
  );
}
